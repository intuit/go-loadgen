package cli

import (
	"errors"
	"fmt"
	"github.com/intuit/go-loadgen/constants"
	loadgen "github.com/intuit/go-loadgen/loadgenerator"
	"github.com/intuit/go-loadgen/metrics"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/spf13/cobra"
	"os"
	"sync"
)

const (
	lineCount                   = "line-count"
	lineLength                  = "line-length"
	fileCount                   = "file-count"
	duration                    = "duration"
	enableRotate                = "enable-log-rotation"
	linesPerSecond              = "lines-per-second"
	multiLinePercent            = "multi-line-percent"
	logRotationMaxSizeMegabytes = "log-rotation-max-size-megabytes"
	enableMetrics               = "enable-metrics"
	metricsServerPort           = "metrics-server-port"
	inputFilePath               = "input-file-path"
	replayCount                 = "replay-count"
	disableTimestamp            = "disable-timestamp"
	customTimestampFormat       = "custom-timestamp-format"
	output                      = "output"
	config                      = "config"
	tags                        = "tags"
	enableConfig                = "enable-config"
	resultLog                   = "result-log"
)

func InputValidation(props *loadgen.LoadGenProperties) {

	if !props.Rotate {
		fmt.Println("Warning. File rotation is disabled. You may run out of disk space if the file grows too large!")
	}
	if props.FileCount > constants.MaxFileCount {
		fmt.Printf("Too many files in --file-count parameter. This program can only support upto %d files\n", constants.MaxFileCount)
		os.Exit(1)
	}
}

var cfgFile string

func printInput(props *loadgen.LoadGenProperties) {
	fmt.Printf("Input values = ")
	fmt.Printf(lineCount+" = %d\n", props.NumOfLinesInMultiLineLog)
	fmt.Printf(lineLength+" = %d\n", props.LineLength)
	fmt.Printf(duration+" = %d\n", props.Duration)
	fmt.Printf(linesPerSecond+" = %d\n", props.Lps)
	fmt.Println(output + " =  %s" + props.FilePath)
	fmt.Printf(multiLinePercent+" = %d\n", props.MultiLinePercent)
	fmt.Printf(disableTimestamp+" = %t\n", props.DisableTimestamp)
	fmt.Printf(customTimestampFormat+" = %s\n", props.CustomTimestampFormat)
	fmt.Printf(enableRotate+" = %t\n", props.Rotate)
	fmt.Printf(logRotationMaxSizeMegabytes+" = %d\n", props.RotateSizeMB)
}

/*
Accepts input commands and flags as arguments and the OS CLI
and binds to the relevant fields within the specified loadgenerator properties struct.
*/

func checkInsufficientArgs(cmd *cobra.Command, args []string) {
	if len(args) >= 1 && (args[0] == "-h" || args[0] == "--h" || args[0] == "--help") {
		cmd.Help()
		os.Exit(1)
	}
}

func Run(props *loadgen.LoadGenProperties) {

	var wg sync.WaitGroup
	wg.Add(1)
	props.Wg = &wg
	var metricsServerPortStr string
	var enableConfigVar bool
	promRegistry := prometheus.NewRegistry()

	rootCmd := &cobra.Command{
		Use:   "loadgen [COMMANDS]",
		Short: "loadgen is a tool which generates test-data (synthetic/replay) at a controlled rate to test logging infrastructure.",
		Run: func(cmd *cobra.Command, args []string) {
			checkInsufficientArgs(cmd, args)
			printInput(props)
		},
	}
	replayFileCmd := &cobra.Command{
		Use:   "replay-file",
		Short: "test data is generated by replaying a file.",
		Args: func(cmd *cobra.Command, args []string) error {
			flagSet := cmd.Flags()
			if flagSet.Changed(inputFilePath) == true {
				filePath := flagSet.Lookup(inputFilePath).Value.String()
				fmt.Println(filePath)
				info, err := os.Stat(filePath)
				if err != nil {
					return errors.New("File does not exist. input-file-path = " + filePath)
				}
				if info.Size() <= 0 {
					return errors.New("Invalid file size. filePath = " + filePath)
				}
			}

			//Check if multiple test termination criteria is defined.
			if flagSet.Changed(duration) && flagSet.Changed(replayCount) {
				return errors.New("Multiple test termination criteria found. You can either define --duration or --replay-count as termination criteria, not both. ")
			}
			return nil
		},
		Run: func(cmd *cobra.Command, args []string) {
			if props.EnableMetrics {
				go metrics.StartMetricsServer(promRegistry, &metricsServerPortStr)
			}
			go loadgen.GenerateLoadFromInputFile(promRegistry, props)
			printInput(props)
			wg.Wait()
		},
	}
	randomStringsCmd := &cobra.Command{
		Use:   "random-strings",
		Short: "test data is generated by producing random alphanumeric strings.",
		Long:  "test data is generated by producing random alphanumeric strings.",
		Args: func(cmd *cobra.Command, args []string) error {
			flagSet := cmd.Flags()
			if !flagSet.Changed(duration) {
				return errors.New("Duration is not specified. This command requires a termination criteria. Specify a duration (s) for this job. ")
			}
			return nil
		},
		Run: func(cmd *cobra.Command, args []string) {
			checkInsufficientArgs(cmd, args)
			if props.EnableMetrics {
				go metrics.StartMetricsServer(promRegistry, &metricsServerPortStr)
			}
			go loadgen.GenerateAlphaNumeric(promRegistry, props)
			wg.Wait()
		},
	}

	//Defining persistent flags for root command
	rootCmd.PersistentFlags().Int64VarP(&props.Duration, duration, "d", constants.DefaultDurationInSeconds, "Duration of the job in seconds")
	rootCmd.PersistentFlags().Int64VarP(&props.Lps, linesPerSecond, "s", constants.DefaultLinesPerSecond, "target lines/second")
	rootCmd.PersistentFlags().Int64VarP(&props.FileCount, fileCount, "", constants.DefaultFileCount, "target requests/sec. Note: log rotation does not work in multi file scenario.")
	rootCmd.PersistentFlags().StringVarP(&cfgFile, config, "", "cfg", "-config /path/to/source/jsonfile")
	rootCmd.PersistentFlags().BoolVarP(&enableConfigVar, enableConfig, "", false, "use config file for configuration (default false)")
	rootCmd.PersistentFlags().StringVarP(&metricsServerPortStr, metricsServerPort, "p", constants.DefaultMetricsServerPort, "prometheus metrics server port. default is port 8080. ")
	rootCmd.PersistentFlags().BoolVarP(&props.EnableMetrics, enableMetrics, "", false, "true, enables prometheus metrics on http://<localhost>:<port>/metric HTTP endpoint for line emit rates and byte count. default is off.")
	rootCmd.PersistentFlags().StringVarP(&props.FilePath, output, "o", "", "file path of output log file ex: /var/tmp/test.log")
	rootCmd.PersistentFlags().BoolVarP(&props.Rotate, enableRotate, "r", false, "by default log rotation is off, use this flag to turn it on. Example --enable-log-rotation will turn log rotation on")
	rootCmd.PersistentFlags().Int64VarP(&props.RotateSizeMB, logRotationMaxSizeMegabytes, "", constants.DefaultMaxFileSize, "Rotate after N MegaBytes. example 100. ")
	rootCmd.PersistentFlags().StringVar(&props.Tags, tags, "t", "Custom hardcoded tags in the form of K=V")
	rootCmd.PersistentFlags().StringVar(&props.ResultLog, resultLog, "", "Path of the results log where metrics such as total_lines_generated will be log.")
	rootCmd.PersistentFlags().StringVar(&props.CustomTimestampFormat, customTimestampFormat, "", "Optional custom timestamp format.The default format is 2006-01-02T15:04:05.000-07:00")

	rootCmd.MarkPersistentFlagRequired(output)
	rootCmd.MarkPersistentFlagRequired(linesPerSecond)

	//Defining local flags for replay file command
	replayFileCmd.Flags().StringVarP(&props.InputSourceFile, inputFilePath, "i", "default.log", "file path of output log file ex: /var/tmp/test.log")
	replayFileCmd.MarkFlagRequired(inputFilePath)

	replayFileCmd.Flags().Int64VarP(&props.ReplayCount, replayCount, "", 0, "max number of replays. default is infinite, the replay stops when test duration expires.")
	rootCmd.PersistentFlags().BoolVarP(&props.DisableTimestamp, disableTimestamp, "x", false, "use --disable-timestamp false will disable timestamp injection while replaying logs. "+
		"When this flag is not used. Do not modify this parameter for auto-generated random alphanumberic logs."+
		"Disabling timestamps is typically suitable while replaying a log-file with pre-existing timestamps.")

	//Defining local flags for random string generator command
	randomStringsCmd.Flags().IntVarP(&props.MultiLinePercent, multiLinePercent, "m", constants.DefaultMultiLinePercentage, " % of log entries which have multiple lines, example: 1% will generate ")
	randomStringsCmd.Flags().IntVarP(&props.NumOfLinesInMultiLineLog, lineCount, "n", constants.DefaultMultiLineCount, "max number of lines in multiline log entry")
	randomStringsCmd.Flags().Int64VarP(&props.LineLength, lineLength, "l", constants.DefaultLineLength, "line length(number of characters)")
	randomStringsCmd.MarkFlagRequired(lineCount)
	randomStringsCmd.MarkFlagRequired(lineLength)
	randomStringsCmd.MarkFlagRequired(multiLinePercent)

	rootCmd.AddCommand(randomStringsCmd, replayFileCmd)

	err := rootCmd.Execute()
	InputValidation(props)
	if err != nil {
		error.Error(err)
		os.Exit(1)
	}
}
